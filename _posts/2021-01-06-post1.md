---
title: 첫번째 포스팅
---

# 1. 첫번째 포스팅
오늘 처음으로 자료구조를 공부했다.

내가 공부한 부분은 이진탐색 알고리즘으로
배열의 중앙에 찾는 값이 저장되어있는지 
계속 확인하면서 결국 내가 찾고 있는 결과값을 
알아내는 방식이다. 

예제 코드를 확인해보자.

	#include<stdio.h>

	int BSearch(int ar[],int len, int target)
	{
		int first = 0;
		int last = len-1;
		int mid;
	
		while(first <= last)
		{
			mid = (first+last) / 2;

			if(target == ar[mid])
			{
				return mid;
			}
			else
			{
				if(target <ar[mid])
					last = mid -1;
				else
					first = mid+1;
			}
		}
		return -1;
	}

	int main(void)
	{
		int arr[] ={1,3,5,7,9};
		int idx;

		idx = BSearch(arr,sizeof(arr)/sizeof(int),7);
		if(idx == -1)
			printf("탐색실패\n");
		else
			printf("타겟 저장 인덱스:%d \n",idx);
		
		idx = BSearch(arr,sizeof(arr)/sizeof(int),4);
		if(idx == -1)
			printf("탐색실패\n");
		else
			printf("타겟 저장 인덱스:%d \n",idx);

		return 0;
	
	}

이 코드의 결과값으로는 

    타겟 저장 인덱스:3

    탐색실패

가 나온다. 

이때 

	if(target < ar[mid])	
 
    	last = mid -1;

에서 mid-1이 나온 이유는 , 만약 내가 찾는 값의 숫자가 중간에 위치해 있는 값보다 작다면, 중간에 위치해있는 값이 마지막 값이 된 후 처음부터 마지막값이 된 중간값 사이에 내가 찾는 값이 있다고 가정되기 때문이다. 
	
	else
		first = mid+1;

에서 mid+1이 나온 이유는, 만약 내가 찾는 값의 숫자가 중간에 위치해 있는 값보다 크거나 같다면, 중간에 위치해 있는 값이 첫번째값이 된 후 처음 값이 된 중간값과 마지막 값 사이에 내가 찾는 값이 있다고 가정되기 때문이다.

그런데 이때 의문이 드는 것은 그냥 
    last = mid, 혹은 fisrt = mid로 써도 가능하지 않을까 라는 것이다. 
    mid에 저장되어있는 값은 범위 값이지 mid 범위가 가지고 있는 숫자 값이아니다. 우리는 이미 앞에서 mid범위에 들어있는 숫자 값을 확인했고, 이는 이제 더이상 확인하지않아도 되는 범위이기 때문에 이보다 하나 더 앞에 있는 범위의 숫자와 이보다 하나 더 뒤에  있는 범위의 숫자를 확인해주면된다. 따라서 +1과 -1을 붙여주게 되는데, 만약 이때 이 값을 더해주거나 빼주지 않으면 어떻게 될까?

우리가 +1과 -1을 해주는데는 이유가 있다는 말이 여기서 보여지게 된다. 만약 first와 mid사이에 내가 찾는 값이 존재하지 않는다면 이제 fisrt에 저장된 값이 기존의 last값보다 커져 반복문을 탈출해 다시 새로운 반복문으로 들어가야 하는데, 만약 이때 first = mid가 된다면 기존의 last값과 같은 상태가 되고, 따라서 fist의 값이 last보다 커질 수 없게 되므로 반복문에서 빠져나올수 없는 무한루프 상태가 되어버린다. 

last = mid, fisrt = mid로 바꾸어 코드를 실행시키면 처음 값은 나올텐데 두번째 값이 무한루프를 형성하여 종료되지 않음을 볼 수 있다. 

처음으로 자료구조를 공부해봤는데, 쉽지않다. 벌써부터 올해가 아득하다. 오늘 이 다음 예제를 보고 또 이해해야한다. 너무 가혹하다. 코딩의 세계는 너무 험난하다. 이만하고 다음내용을  공부하러 가야겠다. 
    


